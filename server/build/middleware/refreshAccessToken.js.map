{"version":3,"file":"refreshAccessToken.js","names":["_passportOauth2Refresh","_interopRequireDefault","require","_User","obj","__esModule","default","refreshTokenMiddleware","req","res","next","tokenExpirationBuffer","user","tokenExpiresAt","Date","now","refresh","requestNewAccessToken","refreshToken","err","accessToken","console","error","Error","userForUpdate","getTime","User","findByIdAndUpdate","_id","updateErr","_default","exports"],"sources":["../../src/middleware/refreshAccessToken.js"],"sourcesContent":["import refresh from 'passport-oauth2-refresh';\nimport User from '../models/User';\n\n// Middleware to check if the access token is about to expire\nconst refreshTokenMiddleware = async (req, res, next) => {\n  const tokenExpirationBuffer = 60000; // 1 minute buffer for token expiration\n\n  if (req.user && req.user.tokenExpiresAt && new Date(req.user.tokenExpiresAt) - tokenExpirationBuffer < Date.now()) {\n    refresh.requestNewAccessToken('google-authcode', req.user.refreshToken, async (err, accessToken, refreshToken) => {\n      if (err) {\n        console.error('Error refreshing token:', err);\n        return next(err);\n      }\n\n      if (!accessToken) {\n        console.error('Access token not received after refresh.');\n        // Handle this case, possibly by forcing reauthorization or another approach.\n        return next(new Error('Failed to obtain a new access token.'));\n      }\n\n      let userForUpdate = {\n        accessToken,\n        tokenExpiresAt: new Date().getTime() + 3600000, // adds 1 hour to current time\n      };\n\n      if (refreshToken) {\n        userForUpdate.refreshToken = refreshToken;\n      }\n\n      try {\n        await User.findByIdAndUpdate(req.user._id, userForUpdate);\n        req.user.accessToken = accessToken; // Update the access token in the user object immediately\n        req.user.tokenExpiresAt = userForUpdate.tokenExpiresAt; // Update the token expiration time in the user object immediately\n        req.user.refreshToken = refreshToken || req.user.refreshToken; // Update the refresh token in the user object immediately\n        next();\n      } catch (updateErr) {\n        console.error('Error updating user:', updateErr);\n        next(updateErr);\n      }\n    });\n  } else {\n    next();\n  }\n};\n\nexport default refreshTokenMiddleware;\n"],"mappings":";;;;;;AAAA,IAAAA,sBAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,KAAA,GAAAF,sBAAA,CAAAC,OAAA;AAAkC,SAAAD,uBAAAG,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAElC;AACA,MAAMG,sBAAsB,GAAG,MAAAA,CAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;EACvD,MAAMC,qBAAqB,GAAG,KAAK,CAAC,CAAC;;EAErC,IAAIH,GAAG,CAACI,IAAI,IAAIJ,GAAG,CAACI,IAAI,CAACC,cAAc,IAAI,IAAIC,IAAI,CAACN,GAAG,CAACI,IAAI,CAACC,cAAc,CAAC,GAAGF,qBAAqB,GAAGG,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IACjHC,8BAAO,CAACC,qBAAqB,CAAC,iBAAiB,EAAET,GAAG,CAACI,IAAI,CAACM,YAAY,EAAE,OAAOC,GAAG,EAAEC,WAAW,EAAEF,YAAY,KAAK;MAChH,IAAIC,GAAG,EAAE;QACPE,OAAO,CAACC,KAAK,CAAC,yBAAyB,EAAEH,GAAG,CAAC;QAC7C,OAAOT,IAAI,CAACS,GAAG,CAAC;MAClB;MAEA,IAAI,CAACC,WAAW,EAAE;QAChBC,OAAO,CAACC,KAAK,CAAC,0CAA0C,CAAC;QACzD;QACA,OAAOZ,IAAI,CAAC,IAAIa,KAAK,CAAC,sCAAsC,CAAC,CAAC;MAChE;MAEA,IAAIC,aAAa,GAAG;QAClBJ,WAAW;QACXP,cAAc,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACW,OAAO,CAAC,CAAC,GAAG,OAAO,CAAE;MAClD,CAAC;MAED,IAAIP,YAAY,EAAE;QAChBM,aAAa,CAACN,YAAY,GAAGA,YAAY;MAC3C;MAEA,IAAI;QACF,MAAMQ,aAAI,CAACC,iBAAiB,CAACnB,GAAG,CAACI,IAAI,CAACgB,GAAG,EAAEJ,aAAa,CAAC;QACzDhB,GAAG,CAACI,IAAI,CAACQ,WAAW,GAAGA,WAAW,CAAC,CAAC;QACpCZ,GAAG,CAACI,IAAI,CAACC,cAAc,GAAGW,aAAa,CAACX,cAAc,CAAC,CAAC;QACxDL,GAAG,CAACI,IAAI,CAACM,YAAY,GAAGA,YAAY,IAAIV,GAAG,CAACI,IAAI,CAACM,YAAY,CAAC,CAAC;QAC/DR,IAAI,CAAC,CAAC;MACR,CAAC,CAAC,OAAOmB,SAAS,EAAE;QAClBR,OAAO,CAACC,KAAK,CAAC,sBAAsB,EAAEO,SAAS,CAAC;QAChDnB,IAAI,CAACmB,SAAS,CAAC;MACjB;IACF,CAAC,CAAC;EACJ,CAAC,MAAM;IACLnB,IAAI,CAAC,CAAC;EACR;AACF,CAAC;AAAC,IAAAoB,QAAA,GAAAC,OAAA,CAAAzB,OAAA,GAEaC,sBAAsB"}